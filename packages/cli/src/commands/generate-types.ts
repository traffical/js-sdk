/**
 * generate-types command
 *
 * Generate TypeScript type definitions from the traffical.yaml config file.
 * This creates a .ts file with strongly-typed parameter keys and event names.
 */

import chalk from "chalk";
import { writeFile, mkdir } from "fs/promises";
import { dirname, join } from "path";
import { findConfigFile, readConfigFile, TRAFFICAL_DIR } from "../lib/config.ts";
import { parseFormatOption } from "../lib/output.ts";

export interface GenerateTypesOptions {
  configPath?: string;
  output?: string;
  format?: string | boolean;
}

export interface GenerateTypesResult {
  success: boolean;
  configPath: string;
  outputPath: string;
  parameters: number;
  events: number;
}

/**
 * Generate TypeScript types from config.
 */
export async function generateTypes(options: {
  configPath?: string;
  output?: string;
}): Promise<GenerateTypesResult> {
  // Find config file
  const configPath = options.configPath || (await findConfigFile());

  if (!configPath) {
    throw new Error(
      `No ${TRAFFICAL_DIR}/config.yaml found. Run 'traffical init' to create one.`
    );
  }

  // Read config
  const config = await readConfigFile(configPath);

  // Determine output path
  const configDir = dirname(configPath);
  const outputPath = options.output || join(configDir, "traffical.generated.ts");

  // Generate type content
  const paramKeys = Object.keys(config.parameters);
  const eventNames = Object.keys(config.events || {});

  let content = `/**
 * Auto-generated Traffical types
 * 
 * Generated from: ${configPath}
 * Do not edit this file manually.
 */

`;

  // Parameter keys union type
  if (paramKeys.length > 0) {
    content += `/**
 * All parameter keys defined in traffical.yaml
 */
export type TrafficalParameterKey =
${paramKeys.map((key) => `  | "${key}"`).join("\n")};

`;

    // Parameter types map
    content += `/**
 * Parameter types by key
 */
export interface TrafficalParameterTypes {
${paramKeys
  .map((key) => {
    const param = config.parameters[key]!;
    let tsType: string;
    switch (param.type) {
      case "string":
        tsType = "string";
        break;
      case "number":
        tsType = "number";
        break;
      case "boolean":
        tsType = "boolean";
        break;
      case "json":
        tsType = "Record<string, unknown>";
        break;
      default:
        tsType = "unknown";
    }
    return `  "${key}": ${tsType};`;
  })
  .join("\n")}
}

`;
  } else {
    content += `/**
 * No parameters defined
 */
export type TrafficalParameterKey = never;

export interface TrafficalParameterTypes {}

`;
  }

  // Event names union type
  if (eventNames.length > 0) {
    content += `/**
 * All event names defined in traffical.yaml
 */
export type TrafficalEventName =
${eventNames.map((name) => `  | "${name}"`).join("\n")};

`;

    // Event types map
    content += `/**
 * Event value types by name
 */
export interface TrafficalEventTypes {
${eventNames
  .map((name) => {
    const event = config.events![name]!;
    let tsType: string;
    switch (event.valueType) {
      case "currency":
        tsType = "number";
        break;
      case "count":
        tsType = "number";
        break;
      case "rate":
        tsType = "number";
        break;
      case "boolean":
        tsType = "boolean";
        break;
      default:
        tsType = "unknown";
    }
    return `  "${name}": ${tsType};`;
  })
  .join("\n")}
}

`;
  } else {
    content += `/**
 * No events defined
 */
export type TrafficalEventName = never;

export interface TrafficalEventTypes {}

`;
  }

  // Helper type for type-safe getParam
  content += `/**
 * Helper type for type-safe parameter access
 */
export type GetParamType<K extends TrafficalParameterKey> = TrafficalParameterTypes[K];

/**
 * Helper type for type-safe event tracking
 */
export type GetEventValueType<N extends TrafficalEventName> = TrafficalEventTypes[N];
`;

  // Ensure output directory exists
  await mkdir(dirname(outputPath), { recursive: true });

  // Write file
  await writeFile(outputPath, content, "utf-8");

  return {
    success: true,
    configPath,
    outputPath,
    parameters: paramKeys.length,
    events: eventNames.length,
  };
}

/**
 * Print result for human-readable output.
 */
function printHuman(result: GenerateTypesResult): void {
  console.log(chalk.dim(`Using config: ${result.configPath}`));
  console.log();
  console.log(`Generated types:`);
  console.log(chalk.dim(`  Parameters: ${result.parameters}`));
  console.log(chalk.dim(`  Events: ${result.events}`));
  console.log();
  console.log(chalk.green(`âœ“ Written to ${result.outputPath}`));
}

export async function generateTypesCommand(options: GenerateTypesOptions): Promise<void> {
  const format = parseFormatOption(options.format);
  const result = await generateTypes(options);

  if (format === "json") {
    console.log(JSON.stringify(result, null, 2));
  } else {
    printHuman(result);
  }
}

